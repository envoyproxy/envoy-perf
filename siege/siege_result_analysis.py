#!/usr/bin/env python3
#
# Reads csv files for clean experimental performance and memory which, are
# generated by running siege multiple times, interleaving clean and
# experimental. Each perf csv file looks something like this:
#
#   Date & Time,         Trans, Elap Time, Data Trans, Resp Time, Trans Rate, Throughput, Concurrent, OKAY,  Failed
#   2018-10-07 09:40:58, 50000, 4.12,      151,        0.00,      12135.92,   36.65,      45.23,      50000, 0
#   2018-10-07 09:41:06, 50000, 3.92, 151, 0.00, 12755.10, 38.52, 47.26, 50000, 0
#   2018-10-07 09:41:13, 50000, 3.47, 151, 0.00, 14409.22, 43.52, 47.62, 50000, 0
#   2018-10-07 09:41:21, 50000, 3.45, 151, 0.00, 14492.75, 43.77, 45.88, 50000, 0
#   2018-10-07 09:41:28, 50000, 3.49, 151, 0.00, 14326.65, 43.27, 46.28, 50000, 0
#
# And the memory csv files look like:
#   EnvoyMem, VSZ, RSS
#   4208832,343468,52508
#   4220184,343468,55032
#   4187648,343472,52200
#   4223848,343468,56532
#   4187192,343472,54928
#
# This script prints out standard deviation for each data-set, to make it
# obvious if it's noisy, and some basic comparisons.
#
# Python3 is required to provide access to the built-in 'statistics' package.
# If this ever becomes an issue, computing mean/stddev wouldn't be too bad.

import csv
import statistics
import sys

# Parses a CSV file into an array of maps from column-name to value.
# https://stackoverflow.com/questions/21572175/convert-csv-file-to-list-of-dictionaries
def parseCsv(file):
  with open(file) as f:
    return [{k: v for k, v in row.items()}
            for row in csv.DictReader(f, skipinitialspace=True)]

# Extracts the values of a particular column-name from the array of maps,
# returning the array of values.
def columnValues(data, column_name):
  # A simple way to write out the column values is:
  #    return [float(row[column_name]) for row in data]
  # However this will fail one of the pieces of data is corrupt. Instead, let's
  # track parse failures overall and manually build up the array of values.
  failures = 0
  values = []
  for row in data:
    try:
      value = float(row[column_name])
      values.append(value)
    except Exception as e:
      print("failure parsing float: `%s`" % str(e))
      failures = failures + 1
  return values, failures

def main(argv):
  if len(argv) != 6:
    print(('Usage: %s clean_perf_csv clean_mem_csv experimental_perf_csv '
           'experimental_mem_csv aggregate_csv') % argv[0])
    sys.exit(1)

  # Save the performance CSV data from the clean and experimental runs, using
  # an array of maps.
  clean = parseCsv(argv[1])
  experimental = parseCsv(argv[3])

  # Write aggregated stats to aggregate.csv
  with open(argv[5], "w") as aggregate:
    aggregate.write(" ,Clean,Std Dev,Failures,Experimental,Std Dev,Failures,Improvement\n")
    aggregate.write(" ,-----,-------,--------,------------,-------,--------,-----------\n")

    # Adds a row to the matrix for later printing, including the medians and
    # standard deviations for a particular column.
    def addRow(metric):
      clean_values, exp_failures = columnValues(clean, metric)
      exp_values, clean_failures = columnValues(experimental, metric)
      mean_clean = statistics.median(clean_values)
      mean_exp = statistics.median(exp_values)
      improvement = "0"
      if mean_clean > 0:
        improvement_percent = 100 * ((mean_clean - mean_exp) / mean_clean)
        improvement = "%s%%" % round(improvement_percent, 3)
      aggregate.write("%s,%s,%s,%s,%s,%s,%s,%s\n" % (
          metric,
          round(mean_clean, 2), round(statistics.stdev(clean_values), 3), exp_failures,
          round(mean_exp, 2), round(statistics.stdev(exp_values), 3), clean_failures,
          improvement))

    # Compute the performance data stats and add them to the matrix.
    addRow("Trans Rate")
    addRow("Throughput")
    addRow("Failed")

    # Now parse the memory CSV data, collate & compute stats, and add those as new
    # rows of the performande matrix.
    clean = parseCsv(argv[2])
    experimental = parseCsv(argv[4])

    addRow("EnvoyMem")
    addRow("VSZ")
    addRow("RSS")

  sys.exit(0)

main(sys.argv)
